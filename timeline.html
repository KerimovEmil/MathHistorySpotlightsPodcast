<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Math History Spotlights Timeline</title>

<!-- favicon link -->
<link rel="shortcut icon" href="./favicon.svg" type="image/svg+xml">

<!-- custom css link -->
<link rel="stylesheet" href="./assets/css/style.css">
<link rel="stylesheet" href="./assets/css/timeline.css">

<!-- google font link -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Josefin+Sans:wght@400;500;700&display=swap" rel="stylesheet">


</head>

<body id="top" class="timeline-page">

<!-- HEADER -->
<site-header></site-header>

<main>
  <article class="container">
    <h2>Math History Spotlights — Timeline</h2>


<div class="controls">
  Zoom:
  <input type="range" id="zoom" min="1200" max="2600" value="1800">
</div>

<div class="legend">
  <h3>Eras:</h3>
  <div class="legend-items">
    <span class="legend-item renaissance">Renaissance (before 1600)</span>
    <span class="legend-item enlightenment">Enlightenment (1600-1750)</span>
    <span class="legend-item classical">Classical (1750-1900)</span>
    <span class="legend-item modern">Modern (after 1900)</span>
  </div>
</div>

<div class="timeline-container">
  <div class="timeline" id="timeline">
    <div class="loading-message" id="loading">Loading timeline data...</div>
  </div>
</div>

<div class="tooltip" id="tooltip"></div>

<script>
const timeline = document.getElementById("timeline");
const tooltip = document.getElementById("tooltip");
const zoom = document.getElementById("zoom");

let data = [];
let minYear = 0;
let maxYear = 0;

// Function to determine era based on birth year
function getEra(birthYear) {
  if (birthYear < 1600) return "renaissance";
  if (birthYear < 1750) return "enlightenment";
  if (birthYear < 1900) return "classical";
  return "modern";
}

// Function to parse episode title and extract mathematician data
function parseTitle(title) {
  // Try to extract name and years from patterns like:
  // "Leonhard Euler 1707 - 1783"
  // "Charles Babbage 1791 Augusta Ada Byron King, Countess of Lovelace 1815 - 1852"
  
  // Match pattern: name followed by year - year
  const match = title.match(/^(.+?)\s+(\d{4})\s*-\s*(\d{4})/);
  if (match) {
    return {
      name: match[1].trim(),
      b: parseInt(match[2]),
      d: parseInt(match[3])
    };
  }
  
  // Try alternative pattern for combined entries
  const match2 = title.match(/(\d{4})\s+(.+?)\s+(\d{4})\s*-\s*(\d{4})/);
  if (match2) {
    return {
      name: match2[2].trim(),
      b: parseInt(match2[3]),
      d: parseInt(match2[4])
    };
  }
  
  return null;
}

// Fetch and parse RSS feed with caching
async function fetchEpisodes() {
  const cacheKey = 'timelineData';
  const cacheExpiry = 24 * 60 * 60 * 1000; // 24 hours
  const cached = localStorage.getItem(cacheKey);
  const now = Date.now();

  if (cached) {
    const { data: cachedData, timestamp } = JSON.parse(cached);
    if (now - timestamp < cacheExpiry) {
      data = cachedData;
      minYear = Math.min(...data.map(d => d.b));
      maxYear = Math.max(...data.map(d => d.d));
      render(+zoom.value);
      return;
    }
  }

  try {
    const response = await fetch('https://anchor.fm/s/10cdf4708/podcast/rss');
    if (!response.ok) throw new Error('Network response was not ok');
    const text = await response.text();
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(text, "text/xml");

    const items = xmlDoc.querySelectorAll("item");
    const parsedData = [];

    items.forEach(item => {
      const titleElement = item.querySelector("title");
      const linkElement = item.querySelector("link");
      if (titleElement && linkElement) {
        const title = titleElement.textContent;
        const url = linkElement.textContent;
        const parsed = parseTitle(title);
        if (parsed) {
          parsedData.push({
            ...parsed,
            era: getEra(parsed.b),
            note: `Episode: ${title}`,
            url: url
          });
        }
      }
    });

    // Sort by birth year
    parsedData.sort((a, b) => a.b - b.b);

    data = parsedData;
    localStorage.setItem(cacheKey, JSON.stringify({ data, timestamp: now }));

    if (data.length > 0) {
      minYear = Math.min(...data.map(d => d.b));
      maxYear = Math.max(...data.map(d => d.d));
      render(+zoom.value);
    } else {
      timeline.innerHTML = '<div style="padding: 20px; color: var(--heliotrope-gray);">No timeline data available.</div>';
    }
  } catch (error) {
    console.error("Error fetching episodes:", error);
    const cachedFallback = cached ? JSON.parse(cached).data : null;
    if (cachedFallback) {
      data = cachedFallback;
      minYear = Math.min(...data.map(d => d.b));
      maxYear = Math.max(...data.map(d => d.d));
      render(+zoom.value);
      timeline.insertAdjacentHTML('afterbegin', '<div style="padding: 10px; background: #ef4444; color: white; margin-bottom: 10px;">Using cached data. Refresh to try loading latest.</div>');
    } else {
      timeline.innerHTML = '<div style="padding: 20px; color: #ef4444;">Unable to load timeline data. Please check your internet connection and try again later.</div>';
    }
  }
}

function render(width) {
  if (data.length === 0) return;
  
  timeline.style.width = width + "px";
  timeline.innerHTML = `<div class="axis"></div>`;

  const yearToX = y => ((y - minYear) / (maxYear - minYear)) * width;

  for (let y = minYear; y <= maxYear; y += 50) {
    const tick = document.createElement("div");
    tick.className = "year";
    tick.style.left = yearToX(y) + "px";
    tick.textContent = y;
    timeline.appendChild(tick);
  }

  data.forEach((p, i) => {
    const bar = document.createElement("div");
    bar.className = `person ${p.era}`;
    bar.style.left = yearToX(p.b) + "px";
    bar.style.width = (yearToX(p.d) - yearToX(p.b)) + "px";
    bar.style.top = (i * 28) + "px";
    bar.style.animationDelay = (i * 0.03) + "s";
    bar.textContent = `${p.name} (${p.b}–${p.d})`;
    bar.setAttribute("role", "button");
    bar.setAttribute("tabindex", "0");
    bar.setAttribute("aria-label", `Click to listen: ${p.name}, born ${p.b}, died ${p.d}. ${p.note}`);

    bar.addEventListener("click", () => window.open(p.url, '_blank'));

    const showTooltip = (e) => {
      tooltip.style.opacity = 1;
      tooltip.style.left = (e.pageX || e.touches[0].pageX) + 12 + "px";
      tooltip.style.top = (e.pageY || e.touches[0].pageY) + 12 + "px";
      tooltip.innerHTML = `<strong>${p.name}</strong><br>${p.note}<br><em>Click to listen</em>`;
    };

    const hideTooltip = () => {
      tooltip.style.opacity = 0;
    };

    bar.addEventListener("mousemove", showTooltip);
    bar.addEventListener("touchstart", showTooltip);
    bar.addEventListener("mouseleave", hideTooltip);
    bar.addEventListener("touchend", hideTooltip);
    bar.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        showTooltip({ pageX: bar.offsetLeft + bar.offsetWidth / 2, pageY: bar.offsetTop });
        setTimeout(hideTooltip, 3000); // Hide after 3 seconds
      }
    });
    bar.addEventListener("focus", (e) => {
      showTooltip({ pageX: bar.offsetLeft + bar.offsetWidth / 2, pageY: bar.offsetTop });
    });
    bar.addEventListener("blur", hideTooltip);

    timeline.appendChild(bar);
  });
}

zoom.addEventListener("input", e => render(+e.target.value));

// Initialize by fetching episodes
fetchEpisodes();
</script>

  </article>
</main>

<!-- ionicon link -->
<script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script>
<script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script>

<!-- web components -->
<script type="module" src="./assets/js/site-header.js"></script>
<script type="module" src="./assets/js/site-footer.js"></script>

</body>
</html>
